[
  {
    "id": 1,
    "description": "Missing index on WHERE clause",
    "schema": "\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT,\n    age INTEGER,\n    city TEXT,\n    created_at TEXT\n);\n",
    "slow_query": "SELECT * FROM users WHERE age > 30;",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_users_age ON users(age);\nSELECT * FROM users WHERE age > 30;\n",
    "explanation": "Added index on age column for faster filtering",
    "optimization_type": "indexing"
  },
  {
    "id": 2,
    "description": "SELECT * wastes I/O bandwidth",
    "schema": "\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    description TEXT,\n    price REAL,\n    category TEXT,\n    stock INTEGER,\n    warehouse_location TEXT,\n    supplier_info TEXT\n);\n",
    "slow_query": "SELECT * FROM products WHERE category = 'electronics';",
    "fast_query": "SELECT id, name, price, stock FROM products WHERE category = 'electronics';",
    "explanation": "Only select columns you need to reduce I/O",
    "optimization_type": "projection"
  },
  {
    "id": 3,
    "description": "IN subquery can be replaced with JOIN",
    "schema": "\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    amount REAL,\n    status TEXT\n);\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT\n);\n",
    "slow_query": "\nSELECT name, email FROM users \nWHERE id IN (SELECT user_id FROM orders WHERE amount > 100);\n",
    "fast_query": "\nSELECT DISTINCT u.name, u.email \nFROM users u \nINNER JOIN orders o ON u.id = o.user_id \nWHERE o.amount > 100;\n",
    "explanation": "JOIN is more efficient than IN with subquery",
    "optimization_type": "join"
  },
  {
    "id": 4,
    "description": "Missing LIMIT on large table scan",
    "schema": "\nCREATE TABLE logs (\n    id INTEGER PRIMARY KEY,\n    timestamp TEXT,\n    level TEXT,\n    message TEXT,\n    user_id INTEGER\n);\n",
    "slow_query": "SELECT * FROM logs ORDER BY timestamp DESC;",
    "fast_query": "SELECT * FROM logs ORDER BY timestamp DESC LIMIT 100;",
    "explanation": "Add LIMIT when you don't need all rows",
    "optimization_type": "limit"
  },
  {
    "id": 5,
    "description": "Multiple OR conditions inefficient",
    "schema": "\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    category TEXT,\n    price REAL,\n    name TEXT\n);\n",
    "slow_query": "\nSELECT * FROM products \nWHERE category = 'electronics' \n   OR category = 'computers' \n   OR category = 'phones';\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_products_category ON products(category);\nSELECT * FROM products \nWHERE category IN ('electronics', 'computers', 'phones');\n",
    "explanation": "Use IN instead of multiple ORs and add index",
    "optimization_type": "indexing"
  },
  {
    "id": 6,
    "description": "Missing composite index for multi-column filter",
    "schema": "\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    status TEXT,\n    created_at TEXT,\n    amount REAL\n);\n",
    "slow_query": "\nSELECT * FROM orders \nWHERE user_id = 123 AND status = 'pending';\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_orders_user_status ON orders(user_id, status);\nSELECT * FROM orders \nWHERE user_id = 123 AND status = 'pending';\n",
    "explanation": "Composite index for multiple WHERE conditions",
    "optimization_type": "indexing"
  },
  {
    "id": 7,
    "description": "Function call in WHERE prevents index usage",
    "schema": "\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    email TEXT,\n    name TEXT,\n    created_at TEXT\n);\n",
    "slow_query": "\nSELECT * FROM users \nWHERE LOWER(email) = 'test@example.com';\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\nSELECT * FROM users \nWHERE email = 'test@example.com';\n",
    "explanation": "Avoid functions in WHERE clause; store normalized data",
    "optimization_type": "indexing"
  },
  {
    "id": 8,
    "description": "COUNT when you only need to check existence",
    "schema": "\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    amount REAL\n);\n",
    "slow_query": "\nSELECT user_id, \n       (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as order_count\nFROM users u\nWHERE (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) > 0;\n",
    "fast_query": "\nSELECT u.user_id, COUNT(o.id) as order_count\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nGROUP BY u.user_id;\n",
    "explanation": "Use JOIN and GROUP BY instead of correlated subqueries",
    "optimization_type": "join"
  },
  {
    "id": 9,
    "description": "DISTINCT when not needed",
    "schema": "\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT UNIQUE\n);\n",
    "slow_query": "SELECT DISTINCT email FROM users;",
    "fast_query": "SELECT email FROM users;",
    "explanation": "DISTINCT is unnecessary when column is UNIQUE",
    "optimization_type": "redundancy"
  },
  {
    "id": 10,
    "description": "NOT IN can be slow on large tables",
    "schema": "\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER\n);\n",
    "slow_query": "\nSELECT * FROM users \nWHERE id NOT IN (SELECT user_id FROM orders);\n",
    "fast_query": "\nSELECT u.* FROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.user_id IS NULL;\n",
    "explanation": "LEFT JOIN with NULL check faster than NOT IN",
    "optimization_type": "join"
  },
  {
    "id": 11,
    "description": "ORDER BY without supporting index",
    "schema": "\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    price REAL,\n    created_at TEXT\n);\n",
    "slow_query": "\nSELECT * FROM products \nWHERE price > 50 \nORDER BY created_at DESC;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_products_price_created ON products(price, created_at DESC);\nSELECT * FROM products \nWHERE price > 50 \nORDER BY created_at DESC;\n",
    "explanation": "Composite index covering both WHERE and ORDER BY",
    "optimization_type": "indexing"
  },
  {
    "id": 12,
    "description": "LIKE with leading wildcard prevents index use",
    "schema": "\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    sku TEXT\n);\n",
    "slow_query": "\nSELECT * FROM products \nWHERE name LIKE '%laptop%';\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\nSELECT * FROM products \nWHERE name LIKE 'laptop%';\n",
    "explanation": "Avoid leading wildcards; use trailing wildcard with index",
    "optimization_type": "indexing"
  },
  {
    "id": 13,
    "description": "Sorting when order doesn't matter",
    "schema": "\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT,\n    score INTEGER\n);\n",
    "slow_query": "\nSELECT name, email FROM users \nWHERE score > 100 \nORDER BY name;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_users_score ON users(score);\nSELECT name, email FROM users \nWHERE score > 100;\n",
    "explanation": "Remove ORDER BY if ordering isn't required",
    "optimization_type": "redundancy"
  },
  {
    "id": 14,
    "description": "Large table joined first",
    "schema": "\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    amount REAL\n);\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    active INTEGER\n);\n",
    "slow_query": "\nSELECT o.* FROM orders o\nJOIN users u ON o.user_id = u.id\nWHERE u.active = 1;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_users_active ON users(active);\nCREATE INDEX IF NOT EXISTS idx_orders_user ON orders(user_id);\nSELECT o.* FROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.active = 1;\n",
    "explanation": "Filter smaller table first, add indexes",
    "optimization_type": "indexing"
  },
  {
    "id": 15,
    "description": "GROUP BY without index",
    "schema": "\nCREATE TABLE sales (\n    id INTEGER PRIMARY KEY,\n    product_id INTEGER,\n    amount REAL,\n    sale_date TEXT\n);\n",
    "slow_query": "\nSELECT product_id, SUM(amount) as total\nFROM sales\nGROUP BY product_id;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_sales_product ON sales(product_id);\nSELECT product_id, SUM(amount) as total\nFROM sales\nGROUP BY product_id;\n",
    "explanation": "Index on GROUP BY column speeds up aggregation",
    "optimization_type": "indexing"
  },
  {
    "id": 16,
    "description": "UNION when duplicates don't matter",
    "schema": "\nCREATE TABLE active_users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\nCREATE TABLE inactive_users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n",
    "slow_query": "\nSELECT name FROM active_users\nUNION\nSELECT name FROM inactive_users;\n",
    "fast_query": "\nSELECT name FROM active_users\nUNION ALL\nSELECT name FROM inactive_users;\n",
    "explanation": "UNION ALL is faster when you don't need to remove duplicates",
    "optimization_type": "redundancy"
  },
  {
    "id": 17,
    "description": "Correlated subquery in SELECT",
    "schema": "\nCREATE TABLE customers (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    customer_id INTEGER,\n    total REAL\n);\n",
    "slow_query": "\nSELECT \n    c.name,\n    (SELECT SUM(total) FROM orders WHERE customer_id = c.id) as total_spent\nFROM customers c;\n",
    "fast_query": "\nSELECT \n    c.name,\n    COALESCE(SUM(o.total), 0) as total_spent\nFROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id\nGROUP BY c.id, c.name;\n",
    "explanation": "Replace correlated subquery with JOIN",
    "optimization_type": "join"
  },
  {
    "id": 18,
    "description": "OFFSET pagination on large dataset",
    "schema": "\nCREATE TABLE posts (\n    id INTEGER PRIMARY KEY,\n    title TEXT,\n    created_at TEXT\n);\n",
    "slow_query": "\nSELECT * FROM posts \nORDER BY id \nLIMIT 20 OFFSET 10000;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_posts_id ON posts(id);\nSELECT * FROM posts \nWHERE id > 10000 \nORDER BY id \nLIMIT 20;\n",
    "explanation": "Use WHERE with index instead of large OFFSET",
    "optimization_type": "indexing"
  },
  {
    "id": 19,
    "description": "CASE statement in WHERE clause",
    "schema": "\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    category TEXT,\n    price REAL,\n    discount_price REAL\n);\n",
    "slow_query": "\nSELECT * FROM products\nWHERE CASE \n    WHEN discount_price IS NOT NULL THEN discount_price \n    ELSE price \nEND < 50;\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_products_price ON products(price);\nCREATE INDEX IF NOT EXISTS idx_products_discount ON products(discount_price);\nSELECT * FROM products\nWHERE (discount_price IS NOT NULL AND discount_price < 50)\n   OR (discount_price IS NULL AND price < 50);\n",
    "explanation": "Expand CASE to separate conditions for index usage",
    "optimization_type": "indexing"
  },
  {
    "id": 20,
    "description": "Using HAVING when WHERE would work",
    "schema": "\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    status TEXT,\n    amount REAL\n);\n",
    "slow_query": "\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nGROUP BY user_id\nHAVING status = 'completed';\n",
    "fast_query": "\nCREATE INDEX IF NOT EXISTS idx_orders_status_user ON orders(status, user_id);\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nWHERE status = 'completed'\nGROUP BY user_id;\n",
    "explanation": "Use WHERE to filter before grouping, not HAVING",
    "optimization_type": "indexing"
  }
]